<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>~ [POST_TITLE] ~</title>

    <meta name="description" content="[POST_DESCRIPTION - A short snippet of the post content]">
    <link rel="canonical" href="https://yoursite.com/[POST_SLUG].html"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>

    <style>
      body {
        background-color: #3e3b3b;
        color: rgb(136,185,136);
        font-family: monospace;
        margin: 0;
        padding: 10px;
      }
      #terminal {
        white-space: pre-wrap;
        outline: none;
        min-height: 100vh;
      }
      .prompt {
        color: #0ff;
      }
      .input-line {
        display: inline;
        position: relative;
        min-width: 1ch;
        outline: none;
      }
      /* Styling the STATIC content to look like a terminal output */
      /* Kept for 'clear' functionality, but content is now loaded dynamically */
      .post-content-section {
        white-space: normal;
        margin-top: 10px;
        margin-bottom: 20px;
      }
      .post-content-section h1, .post-content-section h2 {
        color: #f00; 
        text-decoration: underline;
        margin-top: 1em;
        margin-bottom: 0.5em;
      }
      .post-content-section pre {
        background-color: #111;
        border: 1px solid #333;
        padding: 8px;
        color: #0ff;
        white-space: pre-wrap;
      }
      
      /* NEW: Styling for dynamically loaded content */
      .post-output {
        white-space: normal;
        margin-top: 10px;
        margin-bottom: 20px;
      }
      .post-output h1, .post-output h2 {
        color: #f00; 
        text-decoration: underline;
        margin-top: 1em;
        margin-bottom: 0.5em;
      }
      .post-output pre {
        background-color: #111;
        border: 1px solid #333;
        padding: 8px;
        color: #0ff;
        white-space: pre-wrap;
      }

      /* Cursor/Hint Styling */
      #shadow-hint {
        position: absolute;
        color: #c1c194;
        pointer-events: none;
        white-space: pre;
        z-index: 1;
      }
    </style>
</head>
<body>
    <div id="terminal" tabindex="0">
        </div>
<script>
const term = document.getElementById('terminal');

// NEW: Initialize Showdown Converter
const converter = new showdown.Converter(); 

let history = [];
let histPos = 0;
// postList will contain slugs without '.md' (e.g., 'post1')
let postList = []; 

const commandList = ['help', 'cat', 'exit', 'clear', 'ls'];

// --- Utility Functions (Shell logic is the same as blog.html) ---
function print(text='') {
  term.innerHTML += text + '\n';
}

async function catFile(fileName) {
  // Use the full filename provided (e.g., 'post.md' or 'post1.md')
  const filePath = `${fileName}`; 
  
  //print(`[Fetching ${filePath}...]`);
  
  try {
    const response = await fetch(filePath);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const markdownText = await response.text();
    
    // Use the converter instance
    const htmlContent = converter.makeHtml(markdownText);
    print(`<div class="post-output">${htmlContent}</div>`);

  } catch (error) {
    // The error message for local server issue
    print(`<span style="color: #f00;">Error: Could not load post from ${filePath}.</span>`);
    print(`<span style="color: #f00;">**REMINDER:** You must run a local web server for this to work.</span>`);
  }
  
  print('\n'); 
  prompt(); // Prompt after async operation completes
}

function focusLastInput() {
  const input = term.querySelector('.input-line:last-child');
  if (input) {
    input.focus();
    term.scrollTop = term.scrollHeight;
  }
}

function findCompletion(input) {
    if (!input) return null;
    const parts = input.trim().split(/\s+/);
    const command = parts[0];
    // This line correctly captures the argument after the command:
    const arg = parts.length > 1 ? parts.slice(1).join(' ') : null;

    // 1. Command completion (e.g., 'c' + TAB -> 'cat')
    if (parts.length === 1 && !input.endsWith(' ')) {
        const matches = commandList.filter(cmd => cmd.startsWith(command));
        return matches.length === 1 ? matches[0] : null;
    }
    
    if (command === 'cat' && arg) {
        // Filter the post list to find matches
        const matches = postList.filter(filename => // <-- FIX 1: Was postManifest
            filename.startsWith(arg)
        );

        if (matches.length === 1) {
            // Found a single match, return the full command
            return 'cat ' + matches[0];
        } else if (matches.length > 1) {
             // More than one match, find the longest common prefix
             let prefix = arg;
             let finished = false;
             while (!finished) {
                 const currentChar = matches[0][prefix.length];
                 if (currentChar && matches.every(match => match.startsWith(prefix + currentChar))) {
                     prefix += currentChar;
                 } else {
                     finished = true;
                 }
             }
             // Only return the prefix if it's longer than the current arg
             return prefix.length > arg.length ? 'cat ' + prefix : null;
        }
    }
    
    return null;
}

// Function to handle the Tab key press (UPDATED)
function handleTab(inputElement) {
    const currentText = inputElement.textContent.trim();
    const completedText = findCompletion(currentText);

    if (completedText) {
        // If the completion is just the command, add a space after it
        const isCommandCompletion = commandList.includes(completedText) && !currentText.includes(' ');
        let newText = completedText;
        if (isCommandCompletion) {
            newText += ' ';
        }

        inputElement.textContent = newText;
        // Move cursor to the end of the newly completed text
        const range = document.createRange();
        const sel = window.getSelection();
        range.setStart(inputElement.childNodes[0] || inputElement, newText.length);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
    } 
    
    // If no unique completion, check if we need to list matches
    else if (currentText) {

        // Check for file matches
        const [command, arg] = currentText.split(/\s+/);
        if (command === 'cat' && arg) {
            const fileMatches = postList.filter(filename => filename.startsWith(arg)); // <-- FIX 2: Was postManifest
            if (fileMatches.length > 1) {
                inputElement.outerHTML = `<span>${currentText}</span>`;
                print();
                print(fileMatches.join('  '));
                print();
                prompt(); 
                return true;
            }
        }
        // Check for command matches
        const commandMatches = commandList.filter(cmd => cmd.startsWith(currentText));
        if (commandMatches.length > 1) {
            inputElement.outerHTML = `<span>${currentText}</span>`;
            print();
            print(commandMatches.join('  '));
            print();
            prompt(); 
            return true;
        }
    }
    
    // Prevent default browser behavior (e.g., jumping focus)
    return true; 
}

function updateShadowHint(inputElement) {
    const currentText = inputElement.textContent.trim();
    const completedText = findCompletion(currentText);

    let hintHTML = '';
    if (completedText && completedText.length > currentText.length) {
        let finalCompletion = completedText;
        if (commandList.includes(completedText) && !currentText.includes(' ')) {
             finalCompletion += ' ';
        }
        const padding = currentText.padEnd(finalCompletion.length, '');
        const hintText = finalCompletion.substring(currentText.length);
        hintHTML = `<span style="opacity:0;">${padding}</span>${hintText}`;
    }
    
    let shadowHint = inputElement.previousElementSibling;
    if (shadowHint && shadowHint.id === 'shadow-hint') {
        shadowHint.innerHTML = hintHTML;
    }
}


function updatePromptListeners() {
  const input = term.querySelector('.input-line:last-child');
  
  const shadowHint = document.createElement('span');
  shadowHint.id = 'shadow-hint';
  input.parentNode.insertBefore(shadowHint, input);

  input.addEventListener('input', () => {
      updateShadowHint(input);
  });
  
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const cmd = input.textContent.trim();
      history.push(cmd);
      histPos = history.length;
      run(cmd);
    } else if (e.key === 'Tab') {
        e.preventDefault();
        if (handleTab(input)) {
            updateShadowHint(input);
        }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (histPos > 0) input.textContent = history[--histPos];
      else input.textContent = '';
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (histPos < history.length - 1) input.textContent = history[++histPos];
      else input.textContent = '';
    }
    
    setTimeout(() => updateShadowHint(input), 0);

  });
}


function prompt() {
  term.innerHTML += `<span class="prompt">user@post:~$ </span><span class="input-line" contenteditable="true" autofocus></span>`;
  updatePromptListeners();
  focusLastInput();
}

// --- Command Logic for Post Page ---
const staticCommands = {
  help: `Available commands:
  help      - show this help
  ls        - list available posts (from POSTLIST.txt)
  cat [file] - display a post file (e.g., 'cat post1')
  exit      - return to the blog index
  clear     - clear the terminal`
};

function run(cmd) {
  const inputLine = term.querySelector('.input-line:last-child');
  inputLine.outerHTML = `<span>${cmd}</span>`;
  
  const [command, arg] = cmd.split(/\s+/);
  let shouldPrompt = true;

  if (command === 'clear') {
    term.innerHTML = '';
    // Since static content is gone, just print a message on clear
    print('Type \'ls\' to see available posts, or \'help\' for commands.');
  } else if (command === 'exit') {
    // Go back to the blog index/router page
    window.location.href = '../blog.html';
    return;
  } else if (command === 'ls') {
    if (postList.length === 0) {
      print('\nls: Error: Manifest not loaded. Check POSTLIST.txt location and server status.');
    } 
      
    const fileList = postList.map(p => `<span class="file-name">${p}</span>`).join('  ');
    print(`\nTotal posts: ${postList.length}\n${fileList}`);

  } else if (command === 'cat') {
    // NEW LOGIC: Use catFile for dynamic fetching
    if (postList.includes(arg)) {
      // Pass the full file name including extension to catFile
      catFile(`${arg}.md`); 
      shouldPrompt = false; // catFile calls prompt() on completion
    } else if (arg) {
      print(`\ncat: ${arg}: No such file or post. Available: ${postList.join(', ')}`);
    } else {
      print('\ncat: usage: cat [post-name]');
    }
  } else if (staticCommands[cmd]) {
    print('\n' + staticCommands[cmd]);
  } else if (cmd !== '') {
    print(`\nCommand not found: ${cmd}`);
  }
  
  if (shouldPrompt) {
      print('\n');
      prompt();
  }
}

// --- Initialization ---
async function initPost() {
    // 1. Clear any initial content/placeholders
    term.innerHTML = '';

    // 2. Fetch the post list dynamically
    try {
        // **--- CACHE-BUSTING FIX ---**
        // Append a new, unique query parameter (timestamp) to the URL
        const timestamp = new Date().getTime();
        const url = `POSTLIST.txt`; 
        // **---------------------------**

        // IMPORTANT: Assuming POSTLIST.txt is in the same directory.
        const response = await fetch(url, { cache: "no-store" }); // Added cache option for extra measure
        if (response.ok) {
            const text = await response.text();
            // Filter and map: removes empty lines and the '.md' extension
            // We store slugs (e.g., 'post1') in postList
            postList = text.split('\n')
                           .filter(line => line.trim() !== '')
                           .map(line => line.replace(/\.md$/i, ''));
        }
    } catch (error) {
        console.error("Could not load post manifest for cat command:", error);
    }
    
    // 3. Automatically load the main post file: post.md
    // catFile will handle the fetching and call prompt() when done.
    catFile('post.md');
}

document.addEventListener('click', (e) => {
    if (!e.target.classList.contains('input-line')) {
        focusLastInput();
    }
});
initPost();
</script>
</body>
</html>