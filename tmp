<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>~ my blog: /blogpost ~</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>

<style>
  body {
    background-color: #000;
    color: #0f0;
    font-family: monospace;
    margin: 0;
    padding: 10px;
  }
  #terminal {
    white-space: pre-wrap;
    outline: none;
    min-height: 100vh;
  }
  .prompt {
    color: #0ff; /* Cyan prompt */
  }
  .input-line {
    display: inline;
    position: relative; /* Needed for positioning the shadow hint */
    min-width: 1ch; /* Ensure input area is visible */
  }
  .file-name {
    color: #fff;
  }

  /* NEW: Shadow Hint Styling */
  #shadow-hint {
    position: absolute;
    left: 0;
    top: 0;
    color: #333; /* Dark gray for the "shadow" effect */
    pointer-events: none; /* Allows clicks to pass through to the input */
    white-space: pre;
    z-index: 1; /* Ensures it's behind the cursor/input */
  }

  /* Styling Markdown output to look like a terminal */
  .post-output {
    white-space: normal; 
    margin-top: 10px;
    margin-bottom: 10px;
  }
  .post-output h1, .post-output h2 {
    color: #f00; 
    text-decoration: underline;
    margin-top: 1em;
    margin-bottom: 0.5em;
  }
  .post-output pre {
    background-color: #111;
    border: 1px solid #333;
    padding: 8px;
    color: #0ff;
    white-space: pre-wrap;
  }
  .post-output code {
    color: #ff0;
  }
  .post-output a {
    color: #0ff; 
    text-decoration: underline;
  }
</style>
</head>
<body>
<div id="terminal" tabindex="0"></div>
<script>
const term = document.getElementById('terminal');
const converter = new showdown.Converter(); 

let history = [];
let histPos = 0;
let postManifest = []; 

// --- Core Terminal Functions ---

function print(text='') {
  term.innerHTML += text + '\n';
}

function focusLastInput() {
  const input = term.querySelector('.input-line:last-child');
  if (input) {
    input.focus();
    term.scrollTop = term.scrollHeight;
  }
}

// Function to find the best autocompletion match
function findCompletion(input) {
    if (!input) return null;

    const [command, arg] = input.split(/\s+/);
    
    // Only autocomplete if the command is 'cat' and there's a file argument
    if (command === 'cat' && arg) {
        // Filter the post list to find matches
        const matches = postManifest.filter(filename => 
            filename.startsWith(arg)
        );

        if (matches.length === 1) {
            // Found a single match, return the full filename
            return command + ' ' + matches[0];
        } else if (matches.length > 1) {
             // More than one match, find the longest common prefix
             let prefix = arg;
             let finished = false;
             // Find the longest common prefix among the matches
             while (!finished) {
                 const currentChar = matches[0][prefix.length];
                 if (matches.every(match => match.startsWith(prefix + currentChar))) {
                     prefix += currentChar;
                 } else {
                     finished = true;
                 }
             }
             // Only return the prefix if it's longer than the current arg
             return prefix.length > arg.length ? command + ' ' + prefix : null;
        }
    }
    return null;
}

// Function to handle the Tab key press
function handleTab(inputElement) {
    const currentText = inputElement.textContent.trim();
    const completedText = findCompletion(currentText);

    if (completedText) {
        inputElement.textContent = completedText;
        // Move cursor to the end of the newly completed text
        const range = document.createRange();
        const sel = window.getSelection();
        range.setStart(inputElement.childNodes[0] || inputElement, completedText.length);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
    } else if (currentText.startsWith('cat ')) {
        // If there are multiple matches, list them
        const arg = currentText.substring(4);
        const matches = postManifest.filter(filename => 
            filename.startsWith(arg)
        );
        if (matches.length > 1) {
            // Temporarily replace input with list of matches and prompt again
            inputElement.outerHTML = `<span>${currentText}</span>`;
            print();
            print(matches.join('  '));
            print();
            prompt(); // Re-prompt and return
            return true;
        }
    }
    // Prevent default browser behavior (e.g., jumping focus)
    return true; 
}

function updateShadowHint(inputElement) {
    const currentText = inputElement.textContent.trim();
    const completedText = findCompletion(currentText);

    let hintHTML = '';

    if (completedText && completedText.length > currentText.length) {
        // Calculate the necessary padding (spaces) to align the hint
        const padding = currentText.padEnd(completedText.length, '\u00A0'); // Use non-breaking space for accurate width
        const hintText = completedText.substring(currentText.length);
        
        // This hint structure ensures the hint starts exactly where the user input ends
        hintHTML = `<span style="opacity:0;">${padding}</span>${hintText}`;
    }
    
    // Update the hint element within the input's relative container
    let shadowHint = inputElement.previousElementSibling;
    if (shadowHint && shadowHint.id === 'shadow-hint') {
        shadowHint.innerHTML = hintHTML;
    }
}


function updatePromptListeners() {
  const input = term.querySelector('.input-line:last-child');
  
  // Create shadow hint container just before the input line
  const shadowHint = document.createElement('span');
  shadowHint.id = 'shadow-hint';
  input.parentNode.insertBefore(shadowHint, input);

  input.addEventListener('input', () => {
      // Update hint whenever user types
      updateShadowHint(input);
  });
  
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const cmd = input.textContent.trim();
      history.push(cmd);
      histPos = history.length;
      run(cmd);
    } else if (e.key === 'Tab') {
        e.preventDefault(); // Crucial: stop the browser from handling Tab
        if (handleTab(input)) {
            updateShadowHint(input); // Update hint after autocompletion
        }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (histPos > 0) input.textContent = history[--histPos];
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (histPos < history.length - 1) input.textContent = history[++histPos];
      else input.textContent = '';
    }
    
    // Defer hint update slightly if text manipulation happened
    setTimeout(() => updateShadowHint(input), 0);

  });
}

function prompt() {
  term.innerHTML += `<span class="prompt">user@blog:~$ </span><span class="input-line" contenteditable="true" autofocus></span>`;
  updatePromptListeners();
  focusLastInput();
}

// --- Command Logic (Unchanged) ---

const staticCommands = {
  help: `Available commands:
  help      - show this help
  ls        - list all available blog posts
  cat [file] - display the content of a post (e.g., 'cat post1.md')
  exit      - return to the main site terminal
  clear     - clear the terminal`
};

async function catFile(fileName) {
  const filePath = `blogpost/${fileName}`;
  
  print(`[Fetching ${filePath}...]`);
  
  try {
    const response = await fetch(filePath);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const markdownText = await response.text();
    
    const htmlContent = converter.makeHtml(markdownText);
    print(`<div class="post-output">${htmlContent}</div>`);

  } catch (error) {
    print(`<span style="color: #f00;">Error: Could not load post from ${filePath}.</span>`);
    print(`<span style="color: #f00;">**REMINDER:** You must run a local web server for this to work.</span>`);
  }
  
  print('\n'); 
  prompt(); 
}

function run(cmd) {
  const inputLine = term.querySelector('.input-line:last-child');
  inputLine.outerHTML = `<span>${cmd}</span>`;
  
  const [command, arg] = cmd.split(/\s+/);

  if (command === 'clear') {
    term.innerHTML = '';
  } else if (command === 'exit') {
    window.location.href = 'index.html';
    return;
  } else if (command === 'ls') {
    if (postManifest.length === 0) {
      print('\nls: Error: Manifest not loaded. Check server status or POSTLIST.txt.');
      print('\n');
      prompt();
      return;
    }
    const fileList = postManifest.map(p => `<span class="file-name">${p}</span>`).join('  ');
    print(`\nTotal posts: ${postManifest.length}\n${fileList}`);
  } else if (command === 'cat') {
    const postExists = postManifest.includes(arg);
    if (postExists) {
      catFile(arg);
      return; 
    } else if (arg) {
      print(`\ncat: ${arg}: No such file or post.`);
    } else {
      print('\ncat: usage: cat [file.md]');
    }
  } else if (staticCommands[cmd]) {
    print('\n' + staticCommands[cmd]);
  } else if (cmd !== '') {
    print(`\nCommand not found: ${cmd}`);
  }
  
  if (command !== 'cat') { // Only prompt if catFile hasn't been called (since it prompts on async completion)
      print('\n');
      prompt();
  }
}

// --- Initialization Function ---
async function initBlog() {
  print('Welcome to the Blog Terminal (Directory: /blogpost)');
  print('[Fetching post list from POSTLIST.txt...]');

  try {
    const response = await fetch('blogpost/POSTLIST.txt');
    if (!response.ok) {
        throw new Error('Manifest fetch failed. Server not running?');
    }
    const text = await response.text();
    postManifest = text.split('\n').filter(line => line.trim() !== '');

    print(`[Post list loaded. ${postManifest.length} files found.]`);
    print('Type "help" for a list of commands.\n');
  } catch (error) {
    print('<span style="color: #f00;">INIT ERROR: Could not load post list (POSTLIST.txt).</span>');
    print('<span style="color: #f00;">**Please start a local web server (e.g., python -m http.server).**</span>');
    print('\n');
  }
  prompt();
}

// Global click listener to focus the input field
document.addEventListener('click', (e) => {
    if (!e.target.classList.contains('input-line')) {
        focusLastInput();
    }
});

initBlog();
</script>
</body>
</html>